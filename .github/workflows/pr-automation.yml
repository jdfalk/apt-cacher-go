# file: .github/workflows/pr-automation.yml
# version: 1.0.0
# guid: d4e5f6a7-b8c9-0123-def4-123456789013

name: PR Automation

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, labeled, unlabeled]
  pull_request_target:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write
  statuses: write
  security-events: write
  actions: read

jobs:
  # Main unified automation orchestrator
  unified-automation:
    name: Unified PR Automation
    uses: jdfalk/ghcommon/.github/workflows/reusable-unified-automation.yml@main
    with:
      operation: "all"
      # Issue management settings
      im_operations: "auto"
      im_dry_run: false
      im_force_update: false
      im_cleanup_issue_updates: true
      # Documentation settings
      docs_dry_run: false
      docs_cleanup_processed_files: true
      docs_create_pr: false
      docs_auto_merge: false
      docs_continue_on_error: true
      # Labeler settings
      labeler_sync_labels: true
      labeler_dot: true
    secrets: inherit

  # Enhanced super linter for code quality
  super-linter:
    name: Code Quality Check
    uses: jdfalk/ghcommon/.github/workflows/reusable-super-linter.yml@main
    with:
      validate-all-codebase: false
      default-branch: ${{ github.event.repository.default_branch }}
      filter-regex-exclude: ".*\\.git/.*|.*\\.github/copilot/.*|.*\\.vscode/.*|.*node_modules/.*|.*\\.cache/.*|.*vendor/.*|.*dist/.*"
      run-python: false
      run-shell: true
      run-markdown: true
      run-yaml: true
      run-json: true
      run-javascript: false
      run-go: true
      run-github-actions: true
      run-security: true
      enable-auto-fix: false
      auto-commit-fixes: false
    secrets: inherit

  # Backup basic super linter if the reusable one fails
  backup-super-linter:
    name: Backup Code Quality Check
    if: always() && needs.super-linter.result == 'failure'
    needs: [super-linter]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Basic Super Linter
        uses: super-linter/super-linter@v5
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: false
          VALIDATE_GO: true
          VALIDATE_SHELL_SHFMT: true
          VALIDATE_MARKDOWN: true
          VALIDATE_YAML: true
          VALIDATE_JSON: true
          VALIDATE_GITHUB_ACTIONS: true
          SUPPRESS_POSSUM: true
          LOG_LEVEL: NOTICE
          OUTPUT_FORMAT: colored
          OUTPUT_FOLDER: super-linter-output
          OUTPUT_DETAILS: detailed

  # Intelligent issue labeling for PRs
  intelligent-labeling:
    name: Intelligent Labeling
    uses: jdfalk/ghcommon/.github/workflows/reusable-intelligent-issue-labeling.yml@main
    with:
      dry_run: false
      python_version: "3.11"
    secrets: inherit

  # Standard labeler based on file patterns
  standard-labeler:
    name: Standard File-based Labeling
    uses: jdfalk/ghcommon/.github/workflows/reusable-labeler.yml@main
    with:
      configuration-path: ".github/labeler.yml"
      sync-labels: true
      dot: true
    secrets: inherit

  # Post results summary
  post-results:
    name: Post Results Summary
    if: always()
    needs:
      [
        unified-automation,
        super-linter,
        backup-super-linter,
        intelligent-labeling,
        standard-labeler,
      ]
    runs-on: ubuntu-latest
    steps:
      - name: Create PR summary
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              'Unified Automation': '${{ needs.unified-automation.result }}',
              'Super Linter': '${{ needs.super-linter.result }}',
              'Backup Super Linter': '${{ needs.backup-super-linter.result }}',
              'Intelligent Labeling': '${{ needs.intelligent-labeling.result }}',
              'Standard Labeler': '${{ needs.standard-labeler.result }}'
            };

            let summary = '## 🔍 PR Automation Results\\n\\n';
            summary += '| Job | Status | Description |\\n';
            summary += '|-----|--------|-------------|\\n';

            for (const [job, status] of Object.entries(results)) {
              // Skip backup linter if it was skipped (normal case)
              if (job === 'Backup Super Linter' && status === 'skipped') continue;

              const icon = status === 'success' ? '✅' :
                          status === 'failure' ? '❌' :
                          status === 'skipped' ? '⏭️' : '⏸️';
              const statusText = status.charAt(0).toUpperCase() + status.slice(1);

              let description = '';
              switch(job) {
                case 'Unified Automation':
                  description = 'Issue management, docs updates, and workflow orchestration';
                  break;
                case 'Super Linter':
                  description = 'Advanced code quality, style checks, and best practices validation';
                  break;
                case 'Backup Super Linter':
                  description = 'Basic code quality checks (fallback)';
                  break;
                case 'Intelligent Labeling':
                  description = 'AI-powered content analysis and intelligent label assignment';
                  break;
                case 'Standard Labeler':
                  description = 'File pattern-based automatic labeling';
                  break;
              }

              summary += `| ${job} | ${icon} ${statusText} | ${description} |\\n`;
            }

            const failedJobs = Object.entries(results).filter(([job, status]) =>
              status === 'failure' && !(job === 'Backup Super Linter' && results['Super Linter'] === 'success')
            );

            summary += '\\n### Summary\\n\\n';
            if (failedJobs.length === 0) {
              summary += '🎉 **All automation checks passed!** This PR is ready for review.\\n\\n';

              // Add some helpful info about what was checked
              summary += '**Code Quality Checks:**\\n';
              summary += '- Go code formatting and best practices\\n';
              summary += '- Shell script validation\\n';
              summary += '- YAML and JSON syntax validation\\n';
              summary += '- Markdown formatting\\n';
              summary += '- GitHub Actions workflow validation\\n';
              summary += '- Security scanning\\n\\n';

            } else {
              summary += `⚠️ **${failedJobs.length} automation check(s) failed.** Please review and address the issues before merging.\\n\\n`;
              summary += 'Failed checks:\\n';
              failedJobs.forEach(([job, _]) => {
                summary += `- ${job}\\n`;
              });
              summary += '\\n';
            }

            // Add debug information about Super Linter
            if (results['Super Linter'] === 'success' && results['Backup Super Linter'] === 'skipped') {
              summary += '**Super Linter Status:** ✅ Advanced linter completed successfully\\n';
            } else if (results['Super Linter'] === 'failure' && results['Backup Super Linter'] === 'success') {
              summary += '**Super Linter Status:** ⚠️ Advanced linter failed, but backup linter passed\\n';
            } else if (results['Super Linter'] === 'failure' && results['Backup Super Linter'] === 'failure') {
              summary += '**Super Linter Status:** ❌ Both advanced and backup linters failed\\n';
            }

            summary += '\\n---\\n*Automated by PR Automation workflow*';

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('PR Automation Results')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }
